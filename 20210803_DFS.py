'''
DFS
Depth First Search 깊이 우선 탐색
한 경우의 수에 대한 모든 경우의 수 조사 -> 다음 경우의 수 조사
위에서 밑으로 내려가면서 해당 가지의 가장 아래(끝)까지 검사함

                A
           /    |     \
        B       C       D
      / \       |       |  \
    E   F       G      H   I
  /    / \      |     / \
J     K  L    정답    N  O


A-B-E-J  -F-K  -L  -C-G-정답  ->종료


DFS와 스택
위에서 밑으로 내려가면서 경우의 수를 스택에 추가함
A 검사중 -> B, C, D 스택에 추가
B 검사중 -> E, F 스택에 추가
E 검사중 -> J 스택에 추가
J 검사중 -> 추가X
F 검사중 -> K, L 스택에 추가
K 검사중 -> 추가X
L 검사중 -> 추가X
C 검사중 -> G 스택에 추가
G 검사중 -> 정답 스택에 추가
정답 검사중 -> 종료



예) 미로찾기
탈출 가능하면 True, 불가능하면 False 반환

          0 1 2 3 4 5
          
0 시작    0 0 0 0 0 0
1         1 0 1 1 1 0
2         0 0 1 0 1 0
3         0 1 1 0 0 0
4         0 0 1 1 1 1
5         1 0 0 0 0 0

[0,0]부터 한 칸씩 갈 수 있는 방향을 하위로 생각하여 스택에 담고 검사함



[예시코드]

# 스택에 데이터가 있다면
while len(stack)>0:
    
# 정답 여부 검사
    # 스택의 가장 마지막 데이터 추출
    now = stack.pop()
    if now ==dest:
        return True
    x = now[1]
    y = now[0]
    
# 왼쪽으로 이동할 수 있다면
    # 인덱스 값을 벗어나지 않은 이동
    if x - 1 > -1:
        # 갈 수 있는 길이라면 스택에 추가하고 방문 여부를 2로 표시
        if maps[y][x-1] == 0:
            stack.append([y, x-1])
            maps[y][x-1] = 2

# 오른쪽으로 이동할 수 있다면
    if x + 1 < hori:
        # 갈 수 있는 길이라면 스택에 추가하고 방문 여부를 2로 표시
        if maps[y][x+1] == 1:
            stack.append([y, x+1])
            maps[y][x+1] = 2

# 위쪽으로 이동할 수 있다면
    if y - 1 > -1:
        # 갈 수 있는 길이라면 스택에 추가하고 방문 여부를 2로 표시
        if maps[y-1][x] == 1:
            stack.append([y-1, x])
            maps[y-1][x] = 2

# 아래쪽으로 이동할 수 있다면
    if y + 1 < verti:
        # 갈 수 있는 길이라면 스택에 추가하고 방문 여부를 2로 표시
        if maps[y+1][x] == 1:
            stack.append([y+1, x])
            maps[y+1][x] = 2

# 스택에 데이터가 없으면 false
return False

'''

